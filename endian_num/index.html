<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Byte-order-aware numeric types."><title>endian_num - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="endian_num" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (2300c2aef 2025-10-12)" data-channel="nightly" data-search-js="search-8d3311b9.js" data-stringdex-js="stringdex-828709d0.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate endian_num</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../endian_num/index.html">endian_<wbr>num</a><span class="version">0.2.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a></li><li><a href="#optional-features" title="Optional features">Optional features</a></li><li><a href="#related-crates" title="Related crates">Related crates</a></li></ul><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>endian_<wbr>num</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/endian_num/lib.rs.html#1-1528">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Byte-order-aware numeric types.</p>
<p>This crate provides the <a href="struct.Be.html" title="struct endian_num::Be"><code>Be</code></a> (big-endian) and <a href="struct.Le.html" title="struct endian_num::Le"><code>Le</code></a> (little-endian) byte-order-aware numeric types.</p>
<p>Unlike the popular <a href="https://docs.rs/byteorder"><code>byteorder</code></a> crate, which focuses on the action of encoding and decoding numbers to and from byte streams, this crate focuses on the state of numbers.
This is useful to create structs that contain fields of a specific endianness for interoperability, such as in virtio.
In comparison to other crates that focus on state, this crate closely follows naming conventions from <a href="https://doc.rust-lang.org/nightly/core/num/index.html" title="mod core::num"><code>core::num</code></a>, has rich functionality, and extensive documentation of each method.</p>
<p>The core API looks <em>roughly</em> like this (correspondingly for <code>Be</code>):</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(transparent)]
</span><span class="kw">pub struct</span>&lt;T&gt; Le(<span class="kw">pub </span>T);

<span class="kw">impl </span>Le&lt;T: Integer&gt; {
    <span class="kw">pub const fn </span>from_ne(n: T) -&gt; <span class="self">Self</span>;
    <span class="kw">pub const fn </span>from_be(n: Be&lt;T&gt;) -&gt; <span class="self">Self</span>;

    <span class="kw">pub const fn </span>to_ne(<span class="self">self</span>) -&gt; T;
    <span class="kw">pub const fn </span>to_be(<span class="self">self</span>) -&gt; Be&lt;T&gt;;

    <span class="kw">pub const fn </span>to_be_bytes(<span class="self">self</span>) -&gt; [u8; mem::size_of::&lt;<span class="self">Self</span>&gt;()];
    <span class="kw">pub const fn </span>to_le_bytes(<span class="self">self</span>) -&gt; [u8; mem::size_of::&lt;<span class="self">Self</span>&gt;()];
    <span class="kw">pub const fn </span>to_ne_bytes(<span class="self">self</span>) -&gt; [u8; mem::size_of::&lt;<span class="self">Self</span>&gt;()];

    <span class="kw">pub const fn </span>from_be_bytes(bytes: [u8; mem::size_of::&lt;<span class="self">Self</span>&gt;()]) -&gt; <span class="self">Self</span>;
    <span class="kw">pub const fn </span>from_le_bytes(bytes: [u8; mem::size_of::&lt;<span class="self">Self</span>&gt;()]) -&gt; <span class="self">Self</span>;
    <span class="kw">pub const fn </span>from_ne_bytes(bytes: [u8; mem::size_of::&lt;<span class="self">Self</span>&gt;()]) -&gt; <span class="self">Self</span>;
}</code></pre></div>
<p>The types also implement appropriate traits from <a href="https://doc.rust-lang.org/nightly/core/cmp/index.html" title="mod core::cmp"><code>core::cmp</code></a>, <a href="https://doc.rust-lang.org/nightly/core/convert/index.html" title="mod core::convert"><code>core::convert</code></a>, <a href="https://doc.rust-lang.org/nightly/core/fmt/index.html" title="mod core::fmt"><code>core::fmt</code></a>, and <a href="https://doc.rust-lang.org/nightly/core/ops/index.html" title="mod core::ops"><code>core::ops</code></a> and provide additional helper methods for computations.</p>
<p>In addition to widening and byte-reordering <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From"><code>From</code></a> implementations, the endian number types implement conversions to and from arrays of smaller number types of the same ordering.
This is useful in situations, where a larger field has to be treated as multiple smaller field.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>endian_num::Le;

<span class="kw">let </span>a = Le::&lt;u32&gt;::from_ne(<span class="number">0x1A</span>);
<span class="kw">let </span>b = Le::&lt;u32&gt;::from_ne(<span class="number">0x2B00</span>);

<span class="macro">assert_eq!</span>((a + b).to_le_bytes(), [<span class="number">0x1A</span>, <span class="number">0x2B</span>, <span class="number">0x00</span>, <span class="number">0x00</span>]);</code></pre></div><h2 id="optional-features"><a class="doc-anchor" href="#optional-features">§</a>Optional features</h2>
<p>This crate has the following optional features:</p>
<ul>
<li><a href="../bitflags/index.html" title="mod bitflags"><code>bitflags</code></a> — <code>Be</code> and <code>Le</code> implement <a href="../bitflags/traits/trait.Bits.html" title="trait bitflags::traits::Bits"><code>Bits</code></a>, <a href="../bitflags/parser/trait.ParseHex.html" title="trait bitflags::parser::ParseHex"><code>ParseHex</code></a>, and <a href="../bitflags/parser/trait.WriteHex.html" title="trait bitflags::parser::WriteHex"><code>WriteHex</code></a>.</li>
<li>[<code>bytemuck</code>] — <code>Be</code> and <code>Le</code> implement <a href="bytemuck::Zeroable"><code>Zeroable</code></a> and <a href="bytemuck::Pod"><code>Pod</code></a>.</li>
<li><code>linux-types</code> — Type aliases like in <a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/include/uapi/linux/types.h?h=v6.9#n36"><code>linux/types.h</code></a>, such as <a href="type.le32.html" title="type endian_num::le32"><code>le32</code></a>.</li>
<li><a href="../zerocopy/index.html" title="mod zerocopy"><code>zerocopy</code></a> — <code>Be</code> and <code>Le</code> implement <a href="../zerocopy/trait.KnownLayout.html" title="trait zerocopy::KnownLayout"><code>KnownLayout</code></a>, <a href="../zerocopy/trait.Immutable.html" title="trait zerocopy::Immutable"><code>Immutable</code></a>, <a href="../zerocopy/trait.FromBytes.html" title="trait zerocopy::FromBytes"><code>FromBytes</code></a>, and <a href="../zerocopy/trait.IntoBytes.html" title="trait zerocopy::IntoBytes"><code>IntoBytes</code></a>.</li>
</ul>
<h2 id="related-crates"><a class="doc-anchor" href="#related-crates">§</a>Related crates</h2>
<p>Several crates provide alternative approaches to byte-order-aware numeric types:</p>
<ul>
<li><a href="https://docs.rs/endian-type">endian-type</a></li>
<li><a href="https://docs.rs/endian-type-rs">endian-type-rs</a> — Depends on <code>num</code>.</li>
<li><a href="https://docs.rs/endiantype">endiantype</a></li>
<li><a href="https://docs.rs/nora_endian">nora_endian</a></li>
<li><a href="https://docs.rs/simple_endian">simple_endian</a> — Also provides <code>f32</code>, <code>f64</code>, and <code>bool</code> types.</li>
<li><a href="https://docs.rs/zerocopy/0.7/zerocopy/byteorder/index.html"><code>zerocopy::byteorder</code></a> — These types are <a href="../zerocopy/trait.Unaligned.html" title="trait zerocopy::Unaligned"><code>Unaligned</code></a>, which makes them unsuitable for volatile memory operations.</li>
</ul>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Be.html" title="struct endian_num::Be">Be</a></dt><dd>An integer stored in big-endian byte order.</dd><dt><a class="struct" href="struct.Le.html" title="struct endian_num::Le">Le</a></dt><dd>An integer stored in little-endian byte order.</dd></dl><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><dl class="item-table"><dt><a class="type" href="type.be16.html" title="type endian_num::be16">be16</a></dt><dd>A 16-bit unsigned integer stored in big-endian byte order.</dd><dt><a class="type" href="type.be32.html" title="type endian_num::be32">be32</a></dt><dd>A 32-bit unsigned integer stored in big-endian byte order.</dd><dt><a class="type" href="type.be64.html" title="type endian_num::be64">be64</a></dt><dd>A 64-bit unsigned integer stored in big-endian byte order.</dd><dt><a class="type" href="type.be128.html" title="type endian_num::be128">be128</a></dt><dd>A 128-bit unsigned integer stored in big-endian byte order.</dd><dt><a class="type" href="type.le16.html" title="type endian_num::le16">le16</a></dt><dd>A 16-bit unsigned integer stored in little-endian byte order.</dd><dt><a class="type" href="type.le32.html" title="type endian_num::le32">le32</a></dt><dd>A 32-bit unsigned integer stored in little-endian byte order.</dd><dt><a class="type" href="type.le64.html" title="type endian_num::le64">le64</a></dt><dd>A 64-bit unsigned integer stored in little-endian byte order.</dd><dt><a class="type" href="type.le128.html" title="type endian_num::le128">le128</a></dt><dd>A 128-bit unsigned integer stored in little-endian byte order.</dd></dl></section></div></main></body></html>