<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Conditionally transmutes a mutable reference of one type to a mutable reference of another type of the same size and compatible alignment."><title>try_transmute_mut in zerocopy - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-b7b9f40b.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="zerocopy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.95.0-nightly (905b92696 2026-01-31)" data-channel="nightly" data-search-js="search-fb33671b.js" data-stringdex-js="stringdex-b897f86f.js" data-settings-js="settings-170eb4bf.js" ><script src="../static.files/storage-f9617a14.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-12f88f4f.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-f7c3ffd8.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc macro"><a class="skip-main-content" href="#main-content">Skip to main content</a><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">try_transmute_mut</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../zerocopy/index.html">zerocopy</a><span class="version">0.8.39</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">try_<wbr>transmute_<wbr>mut</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#size-compatibility" title="Size compatibility">Size compatibility</a></li><li><a href="#examples" title="Examples">Examples</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate zerocopy</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content" tabindex="-1"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">zerocopy</a></div><h1>Macro <span class="macro">try_<wbr>transmute_<wbr>mut</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/zerocopy/macros.rs.html#852-882">Source</a> </span></div><pre class="rust item-decl"><code>macro_rules! try_transmute_mut {
    ($e:expr) =&gt; { ... };
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Conditionally transmutes a mutable reference of one type to a mutable
reference of another type of the same size and compatible alignment.</p>
<p><em>Note that while the <strong>value</strong> of the referent is checked for validity at
runtime, the <strong>size</strong> and <strong>alignment</strong> are checked at compile time. For
conversions which are fallible with respect to size and alignment, see the
methods on <a href="trait.TryFromBytes.html" title="trait zerocopy::TryFromBytes"><code>TryFromBytes</code></a>.</em></p>
<p>This macro behaves like an invocation of this function:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>try_transmute_mut&lt;Src, Dst&gt;(src: <span class="kw-2">&amp;mut </span>Src) -&gt; <span class="prelude-ty">Result</span>&lt;<span class="kw-2">&amp;mut </span>Dst, ValidityError&lt;<span class="kw-2">&amp;mut </span>Src, Dst&gt;&gt;
<span class="kw">where
    </span>Src: FromBytes + IntoBytes + <span class="question-mark">?</span>Sized,
    Dst: TryFromBytes + IntoBytes + <span class="question-mark">?</span>Sized,
    align_of::&lt;Src&gt;() &gt;= align_of::&lt;Dst&gt;(),
    size_compatible::&lt;Src, Dst&gt;(),
{
    ...
}</code></pre></div>
<p>The types <code>Src</code> and <code>Dst</code> are inferred from the calling context; they cannot
be explicitly specified in the macro invocation.</p>
<h2 id="size-compatibility"><a class="doc-anchor" href="#size-compatibility">§</a>Size compatibility</h2>
<p><code>try_transmute_mut!</code> supports transmuting between <code>Sized</code> types, between
unsized (i.e., <code>?Sized</code>) types, and from a <code>Sized</code> type to an unsized type.
It supports any transmutation that preserves the number of bytes of the
referent, even if doing so requires updating the metadata stored in an
unsized “fat” reference:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>src: <span class="kw-2">&amp;mut </span>[[u8; <span class="number">2</span>]] = <span class="kw-2">&amp;mut </span>[[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>]][..];
<span class="kw">let </span>dst: <span class="kw-2">&amp;mut </span>[u8] = <span class="macro">try_transmute_mut!</span>(src).unwrap();

<span class="macro">assert_eq!</span>(dst.len(), <span class="number">4</span>);
<span class="macro">assert_eq!</span>(dst, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);
<span class="kw">let </span>dst_size = size_of_val(dst);
<span class="macro">assert_eq!</span>(src.len(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(size_of_val(src), dst_size);</code></pre></div><h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>Transmuting between <code>Sized</code> types:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// 0u8 → bool = false
</span><span class="kw">let </span>src = <span class="kw-2">&amp;mut </span><span class="number">0u8</span>;
<span class="macro">assert_eq!</span>(<span class="macro">try_transmute_mut!</span>(src), <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;mut </span><span class="bool-val">false</span>));

<span class="comment">// 1u8 → bool = true
</span><span class="kw">let </span>src = <span class="kw-2">&amp;mut </span><span class="number">1u8</span>;
 <span class="macro">assert_eq!</span>(<span class="macro">try_transmute_mut!</span>(src), <span class="prelude-val">Ok</span>(<span class="kw-2">&amp;mut </span><span class="bool-val">true</span>));

<span class="comment">// 2u8 → bool = error
</span><span class="kw">let </span>src = <span class="kw-2">&amp;mut </span><span class="number">2u8</span>;
<span class="macro">assert!</span>(<span class="macro">matches!</span>(
    <span class="macro">try_transmute_mut!</span>(src),
    Result::&lt;<span class="kw-2">&amp;mut </span>bool, <span class="kw">_</span>&gt;::Err(ValidityError { .. })
));</code></pre></div>
<p>Transmuting between unsized types:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[derive(KnownLayout, FromBytes, IntoBytes, Immutable)]
#[repr(C)]
</span><span class="kw">struct </span>SliceDst&lt;T, U&gt; {
    t: T,
    u: [U],
}

<span class="kw">type </span>Src = SliceDst&lt;u32, u16&gt;;
<span class="kw">type </span>Dst = SliceDst&lt;u16, bool&gt;;

<span class="kw">let </span><span class="kw-2">mut </span>bytes = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>];
<span class="kw">let </span>src = Src::mut_from_bytes(<span class="kw-2">&amp;mut </span>bytes).unwrap();

<span class="macro">assert_eq!</span>(src.t.as_bytes(), [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(src.u.len(), <span class="number">2</span>);
<span class="macro">assert_eq!</span>(src.u.as_bytes(), [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]);

<span class="kw">let </span>dst: <span class="kw-2">&amp;</span>Dst = <span class="macro">try_transmute_mut!</span>(src).unwrap();

<span class="macro">assert_eq!</span>(dst.t.as_bytes(), [<span class="number">0</span>, <span class="number">1</span>]);
<span class="macro">assert_eq!</span>(dst.u, [<span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>, <span class="bool-val">true</span>, <span class="bool-val">false</span>, <span class="bool-val">true</span>]);</code></pre></div></div></details></section></div></main></body></html>