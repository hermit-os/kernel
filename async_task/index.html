<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Task abstraction for building executors."><title>async_task - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="async_task" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0-nightly (2300c2aef 2025-10-12)" data-channel="nightly" data-search-js="search-8d3311b9.js" data-stringdex-js="stringdex-828709d0.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/smol-rs/smol/master/assets/images/logo_fullsize_transparent.png"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate async_task</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../async_task/index.html"><img src="https://raw.githubusercontent.com/smol-rs/smol/master/assets/images/logo_fullsize_transparent.png" alt="logo"></a><h2><a href="../async_task/index.html">async_<wbr>task</a><span class="version">4.7.1</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#structs">Crate Items</a></h3><ul class="block"><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>async_<wbr>task</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/async_task/lib.rs.html#1-118">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Task abstraction for building executors.</p>
<p>To spawn a future onto an executor, we first need to allocate it on the heap and keep some
state attached to it. The state indicates whether the future is ready for polling, waiting to
be woken up, or completed. Such a stateful future is called a <em>task</em>.</p>
<p>All executors have a queue that holds scheduled tasks:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>(sender, receiver) = flume::unbounded();</code></pre></div>
<p>A task is created using either <a href="fn.spawn.html" title="fn async_task::spawn"><code>spawn()</code></a>, [<code>spawn_local()</code>], or <a href="fn.spawn_unchecked.html" title="fn async_task::spawn_unchecked"><code>spawn_unchecked()</code></a> which
return a <a href="struct.Runnable.html" title="struct async_task::Runnable"><code>Runnable</code></a> and a <a href="struct.Task.html" title="struct async_task::Task"><code>Task</code></a>:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// A future that will be spawned.
</span><span class="kw">let </span>future = <span class="kw">async </span>{ <span class="number">1 </span>+ <span class="number">2 </span>};

<span class="comment">// A function that schedules the task when it gets woken up.
</span><span class="kw">let </span>schedule = <span class="kw">move </span>|runnable| sender.send(runnable).unwrap();

<span class="comment">// Construct a task.
</span><span class="kw">let </span>(runnable, task) = async_task::spawn(future, schedule);

<span class="comment">// Push the task into the queue by invoking its schedule function.
</span>runnable.schedule();</code></pre></div>
<p>The <a href="struct.Runnable.html" title="struct async_task::Runnable"><code>Runnable</code></a> is used to poll the task’s future, and the <a href="struct.Task.html" title="struct async_task::Task"><code>Task</code></a> is used to await its
output.</p>
<p>Finally, we need a loop that takes scheduled tasks from the queue and runs them:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">for </span>runnable <span class="kw">in </span>receiver {
    runnable.run();
}</code></pre></div>
<p>Method <a href="struct.Runnable.html#method.run" title="method async_task::Runnable::run"><code>run()</code></a> polls the task’s future once. Then, the <a href="struct.Runnable.html" title="struct async_task::Runnable"><code>Runnable</code></a>
vanishes and only reappears when its <a href="https://doc.rust-lang.org/nightly/core/task/wake/struct.Waker.html" title="struct core::task::wake::Waker"><code>Waker</code></a> wakes the task, thus
scheduling it to be run again.</p>
</div></details><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Builder.html" title="struct async_task::Builder">Builder</a></dt><dd>A builder that creates a new task.</dd><dt><a class="struct" href="struct.FallibleTask.html" title="struct async_task::FallibleTask">Fallible<wbr>Task</a></dt><dd>A spawned task with a fallible response.</dd><dt><a class="struct" href="struct.Runnable.html" title="struct async_task::Runnable">Runnable</a></dt><dd>A handle to a runnable task.</dd><dt><a class="struct" href="struct.ScheduleInfo.html" title="struct async_task::ScheduleInfo">Schedule<wbr>Info</a></dt><dd>Extra scheduling information that can be passed to the scheduling function.</dd><dt><a class="struct" href="struct.Task.html" title="struct async_task::Task">Task</a></dt><dd>A spawned task.</dd><dt><a class="struct" href="struct.WithInfo.html" title="struct async_task::WithInfo">With<wbr>Info</a></dt><dd>Pass a scheduling function with more scheduling information - a.k.a.
<a href="struct.ScheduleInfo.html" title="struct async_task::ScheduleInfo"><code>ScheduleInfo</code></a>.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Schedule.html" title="trait async_task::Schedule">Schedule</a></dt><dd>The trait for scheduling functions.</dd></dl><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><dl class="item-table"><dt><a class="fn" href="fn.spawn.html" title="fn async_task::spawn">spawn</a></dt><dd>Creates a new task.</dd><dt><a class="fn" href="fn.spawn_unchecked.html" title="fn async_task::spawn_unchecked">spawn_<wbr>unchecked</a><sup title="unsafe function">⚠</sup></dt><dd>Creates a new task without <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send"><code>Send</code></a>, <a href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync"><code>Sync</code></a>, and <code>'static</code> bounds.</dd></dl></section></div></main></body></html>